\nomenclatureentry{a\{0,1\}$^n$@[{\{0,1\}$^n$}]\begingroup Set of all n-bit binary strings\nomeqref {0}|nompageref}{1}
\nomenclatureentry{aLen(M)@[{Len(M)}]\begingroup The number of bits that string M consist of\nomeqref {0}|nompageref}{1}
\nomenclatureentry{aLen(M)$_l$@[{Len(M)$_l$}]\begingroup The number of l-bits blocks that string M consist of\nomeqref {0}|nompageref}{1}
\nomenclatureentry{aBlock Length@[{Block Length}]\begingroup The number of bits of a block\nomeqref {0}|nompageref}{1}
\nomenclatureentry{a$\oplus$@[{$\oplus$}]\begingroup Bitwise exclusive-xor operation(XOR)\nomeqref {0}|nompageref}{1}
\nomenclatureentry{a(M,T)@[{(M,T)}]\begingroup Message M and its tag T\nomeqref {0}|nompageref}{1}
\nomenclatureentry{aTag@[{Tag}]\begingroup A short message block used to protect the integrity of plaintext or ciphertext\nomeqref {0}|nompageref}{1}
\nomenclatureentry{aMAC@[{MAC}]\begingroup Message Authentication Code: The algorithm to generate tags\nomeqref {0}|nompageref}{1}
\nomenclatureentry{aTG(M, $\ldots$)@[{TG(M, $\ldots$)}]\begingroup Tag generation stage adopting a MAC scheme. The input of TG is message protected and the parameters in the argument list '$\ldots$'\nomeqref {0}|nompageref}{1}
\nomenclatureentry{aVF(M,T, $\ldots$)@[{VF(M,T, $\ldots$)}]\begingroup Message-Tag pair verification stage. Verify the message M and tag T with the parameters in the arguments list '$\ldots$'. Return 1 if TG(M,$\ldots$) = T and 0 if not.\nomeqref {0}|nompageref}{1}
\nomenclatureentry{a(C$_{origin}$, T$_{origin}$)@[{(C$_{origin}$, T$_{origin}$)}]\begingroup The valid memory frame that the adversary wants to attack\nomeqref {0}|nompageref}{1}
\nomenclatureentry{a(C$_{fake}$,T$_{fake}$)@[{(C$_{fake}$,T$_{fake}$)}]\begingroup The frame that the adversary used to replace (C$_{origin}$,T$_{origin}$)\nomeqref {0}|nompageref}{1}
\nomenclatureentry{aPr[A]@[{Pr[A]}]\begingroup The probability that event A happens\nomeqref {0}|nompageref}{1}
\nomenclatureentry{aUF-CMA@[{UF-CMA}]\begingroup Unforgeability under adaptive Chosen Message Attack\nomeqref {0}|nompageref}{1}
\nomenclatureentry{aForgery(MAC, A)@[{Forgery(MAC, A)}]\begingroup Forgery experiment on a MAC scheme conducted by the adversary A. Return 1 if A succeed a forgery attack otherwise 0\nomeqref {0}|nompageref}{1}
\nomenclatureentry{aF$_{MAC}$@[{F$_{MAC}$}]\begingroup The probability that Forgery(MAC, A)=1 for an adversary A and a MAC scheme\nomeqref {0}|nompageref}{1}
\nomenclatureentry{aAdv$^{F0}_{F1}$@[{Adv$^{F0}_{F1}$}]\begingroup The probability for an adversary to distinguish between two functions F0 and F1\nomeqref {0}|nompageref}{1}
\nomenclatureentry{aPRF@[{PRF}]\begingroup Pseudo-random Function\nomeqref {0}|nompageref}{1}
\nomenclatureentry{aPRP@[{PRP}]\begingroup Pseudo-random Permutation\nomeqref {0}|nompageref}{1}
\nomenclatureentry{aFunc$_k$(M)@[{Func$_k$(M)}]\begingroup Function F processing input M with secret information k\nomeqref {0}|nompageref}{1}
\nomenclatureentry{aE$_k$(M)@[{E$_k$(M)}]\begingroup Encrypt input M with secret key k\nomeqref {0}|nompageref}{1}
\nomenclatureentry{aGF-mult(A,B)@[{GF-mult(A,B)}]\begingroup Galois Field multiplication with A and B\nomeqref {0}|nompageref}{1}
